# Chapter 3. 테스트 코드 작성 순서

- [테스트 코드 작성 순서](#테스트-코드-작성-순서)
    - [초반에 복잡한 테스트부터 시작하면 안 되는 이유](#초반에-복잡한-테스트부터-시작하면-안-되는-이유)
    - [구현하기 쉬운 테스트부터 시작하기](#구현하기-쉬운-테스트부터-시작하기)
    - [예외 상황을 먼저 테스트해야 하는 이유](#예외-상황을-먼저-테스트해야-하는-이유)
    - [완급 조절](#완급-조절)
    - [지속적인 리팩토링](#지속적인-리팩토링)
- [테스트 작성 순서 연습](#테스트-작성-순서-연습)
  - [만료일 계산](#만료일-계산)
    - [쉬운 것부터 테스트](#쉬운-것부터-테스트)
    - [예를 추가하면서 구현을 일반화](#예를-추가하면서-구현을-일반화)
    - [코드 정리: 중복 제거](#코드-정리-중복-제거)
    - [예외 상황 처리](#예외-상황-처리)
    - [다음 테스트 선택: 다시 예외 상황](#다음-테스트-선택-다시-예외-상황)
    - [다음 테스트를 추가하기 전에 리팩토링](#다음-테스트를-추가하기-전에-리팩토링)
    - [예외 상황 테스트 진행 계속](#예외-상황-테스트-진행-계속)
    - [코드 정리: 상수를 변수로](#코드-정리-상수를-변수로)
    - [다음 테스트 선택: 쉬운 테스트](#다음-테스트-선택-쉬운-테스트)
    - [예외 상황 테스트 추가](#예외-상황-테스트-추가)
    - [코드 정리](#코드-정리)
    - [다음 테스트: 10개월 요금을 납부하면 1년 제공](#다음-테스트-10개월-요금을-납부하면-1년-제공)
- [테스트할 목록 정리하기](#테스트할-목록-정리하기)
- [시작이 안 될 때는 단언부터 고민](#시작이-안-될-때는-단언부터-고민)
- [구현이 막히면](#구현이-막히면)

<br>

## 테스트 코드 작성 순서

- 쉬운 경우에서 어려운 경우로 진행
- 예외적인 경우에서 정상적인 경우로 진행
  
<br>

#### 초반에 복잡한 테스트부터 시작하면 안 되는 이유

* 한 번에 구현해야할 코드가 많아진다.
* 테스트를 통과할 만큼만 단순하게 구현하다가, 좀 더 범용적인 구현이 필요할 때 어떻게 구현할지 갈피를 잡기 어려워진다.
* 한 번에 많은 코드를 작성하다 보면, 버그를 만들게 되고 디버깅 하는데 많은 시간을 쓰게 된다.

<br>

#### 구현하기 쉬운 테스트부터 시작하기

<br>

#### 예외 상황을 먼저 테스트해야 하는 이유

* 예외 상황을 고려하지 않은 코드에 예외 상황을 반영하려면,  
코드의 구조를 뒤집거나 중간에 예외 상황을 처리하기 위해 조건문을 중복해서 추가하게 됨  
→ 코드가 복잡해지면서 버그가 발생할 수 있다.
* 그 반대로 초반에 예외 상황을 테스트하면, 예외 상황에 따른 조건이 미리 만들어지기 때문에, 전자의 상황보다 코드 구조의 변경이 적다.  
    → 예외 상황을 처리하지 않아 발생하는 버그도 줄일 수 있다.

<br>

#### 완급 조절

1. 정해진 값을 리턴
2. 값 비교를 이용해서 정해진 값을 리턴
3. 다양한 테스트를 추가하면서 구현을 일반화

뻔한 구현이라도 위 단계를 거쳐서 연습하는 것과 바로 구현하는 것엔 차이가 있다.
이러한 연습은 나중에 구현 방법이 떠오르지 않을 때, 점진적으로 구현을 진행할 수 있는 밑거름이 된다.

<br>

#### 지속적인 리팩토링

> 코드를 잘 변경하려면 변경하기 쉬운 구조를 가져야 하는데, 이를 위한 것이 바로 리팩토링이다.  
> 리팩토링을 통해 이해하고 변경하기 쉽게 코드를 개선함으로써 변화하는 요구 사항을 적은 비용으로 반영할 수 있다. 이는 소프트웨어의 생존 시간을 늘려준다.

* 상수 → 변수, 변수 이름 변경 등 작은 리팩토링은 발견 시 바로 진행
* 메서드 추출 등 메서드 구조에 영향을 주는 리팩토링은 구현 흐름이 눈에 들어온 후에 진행


## 테스트 작성 순서 연습

### 만료일 계산
* 매달 1만 원 선불 납부 시 서비스 이용 가능
* 만료일은 납부일 기준으로 한 달 뒤
* 납부 금액
  * 2개월 이상 요금 납부 가능
  * 10만원 납부 시 서비스 1년 제공

<br>
 
#### 쉬운 것부터 테스트

* 테스트를 추가 시 고려사항

    * [x] *구현하기 쉬운 것부터 먼저 테스트*
    * [ ] 예외 상황을 먼저 테스트

<br>

#### 예를 추가하면서 구현을 일반화

같은 테스트에 대해 검증할 예시를 추가하여 구현을 일반화

<br>

#### 코드 정리: 중복 제거

* 파라미터가 많으면 객체로 변경하여 파라미터 개수를 줄이는 것도 하나의 방법
  * 하지만 *아직 발생하지 않은 상황*에 대해 단정 짓고 코드를 수정할 필요는 없음
  * 같은 파라미터 타입이지만 위치에 따라 의미하는 바가 다른 경우,  
  메서드를 확인하여 쉽게 파악할 수 있다면 객체로 바꾸는 것을 보류해도 좋음
* 테스트 코드의 중복 제거는 고민이 필요함
  * 각 테스트 메서드는 스스로 무엇을 테스트하는지 명확하게 설명할 수 있어야 함
  * 테스트가 검증하고 싶은 내용을 알아보기 힘들다면 좋지 않은 변경

<br>

#### 예외 상황 처리

* `한 달` 추가의 기준 정리
  * 달마다 날이 다르다. (30일/31일, 2월: 28일/29일)
* 납부일의 일자와 한 달 뒤의 일자가 같지 않음

> LocalDate#plusMonths()가 알아서 처리함

<br>

#### 다음 테스트 선택: 다시 예외 상황

* 쉬운 것 vs 예외 상황
* 이전 테스트와 맥락이 이어지는 상황을 선택해 해당 조건의 테스트를 마무리
* 추가된 개념에 따라 코드 수정이 필요하게 됨

> 1개월 요금 지불에 대한 예외상황을 테스트 했으니, 2개월 이상 요금을 지불하는 테스트를 진행

<br>

#### 다음 테스트를 추가하기 전에 리팩토링

* 파라미터의 개수가 늘어나면 객체로 변경하여 줄이는 것을 고려
* 리팩토링 시 항상 기존 테스트를 통과하는지 확인
  
1. 클래스 새로 정의
2. 해당 타입을 파라미터로 받는 메서드 추가
3. 기존 테스트 코드를 (2)에 추가한 메서드를 호출하도록 변경
4. 해당 타입을 파라미터로 받는 assert 편의 메서드 추가
5. 기존 테스트 코드를 (4)에서 추가한 메서드를 호출하도록 변경
6. 리팩토링 후 테스트를 통과한다면, 사용하지 않는 기존 메서드는 삭제

> 생성 시, 생성자의 파라미터가 많다면 Builder 패턴 고려

<br>

#### 예외 상황 테스트 진행 계속

* 추가된 개념에 따라 코드 수정
* 상수를 이용해 테스트 통과
* 발생하는 예외에 대한 처리
* 다른 테스트 예시를 추가하여, 테스트를 통과할 만큼만 구현
* 점진적으로 구현을 일반화

<br>

#### 코드 정리: 상수를 변수로

* 상황에 따라 변경될 수 있는 개념(상수)은 변수로 변경
  
```java
// before
payDate.getBillingDate().plusMonths(1);

// after
int addedMonths = 1;
payDate.getBillingDate().plusMonths(addedMonths);
```

<br>

#### 다음 테스트 선택: 쉬운 테스트

<br>

#### 예외 상황 테스트 추가

* 테스트 추가 중 예외 발생 시,  
  예외 상황이 발생하지 않는 조건을 도출하여 코드에 적용

> 예) 첫 납부일: 2019-01-31, 2019-02-28에 20,000원 납부 → 다음 만료일: 2019-04-30  
> * 2019-04-31이 되어서 Exception 발생
>   * 예외 상황이 발생하지 않도록 `후보 만료일이 포함된 달의 마지막 날 < 첫 납부일의 일자` 에 대해 처리
> ```java
> if (YearMonth.from(candidateExp).lengthOfMonth() < payData.getFirstBillingDate().getDayOfMonth()) {
>     return candidateExp.withDayOfMonth(YearMonth.from(candidateExp).lengthOfMonth());
>}
> ```

<br>

#### 코드 정리

* 중복된 로직의 결과는 변수로 빼서 정리
* 로직이 잘 파악되게 끔 코드 정리 (분기 개선, 메서드 추출 등)

https://github.com/2jigoo/BookStudy-StartTdd/blob/ddd64ebdf5fc1fae550d647695dcad4a5ca77f71/src/test/java/chap03/ExpriyDateCalculator.java#L7-L31

<br>

#### 다음 테스트: 10개월 요금을 납부하면 1년 제공

* 테스트 추가
* 테스트가 통과하게끔 구현
* 점진적인 구현 일반화

> 납부금액이 100,000원 여부 확인 후 추가 이용개월 수 계산  
> ```java
> int addedMonths = payData.getPayAmount() == 100_000 ? 12 : payData.getPayAmount() / 10_000;
> ```

<br>

## 테스트할 목록 정리하기

* 시작할 때 테스트할 목록을 미리 정리
* 그 중 어떤 테스트가 구현이 가장 쉬울지, 어떤 상황이 예외적인지 파악
* 구현의 난이도와 구조를 검토하여 다음 테스트를 선택
* 새롭게 발견되는 테스트 사례에 대해 추적
  * 처음부터 완벽한 테스트 목록을 구성하는 것은 어려움
  * 구현하면서 발견되는 테스트 사례를 놓치지 않도록 관리
* 한 번에 테스트는 금물, 작은 단위로 테스트 가져가기
  * 개발의 크기가 클 수록 구현도 어렵고 리팩토링도 어렵다
* 리팩토링의 범위가 큰 경우엔, 리팩토링보다도 테스트를 통과하는데 우선 집중
  * 대신 다음 task로 관리하여 놓치지 않고 진행

> 예)
> * 1만원 납부하면 한 달 뒤가 만료일
> * 달의 마지막 날에 납부하면 다음달 마지막 날이 만료일
> * 2만원 납부하면 2개월 뒤가 만료일
> * 3만원 납부하면 3개월 뒤가 만료일
> * 10만원을 납부하면 1년 뒤가 만료일

<br>

## 시작이 안 될 때는 단언부터 고민

<br>

## 구현이 막히면

구현이 막혀 방향 잡기가 어려울 때, 과감히 코드를 지우고 다시 시작하여 복기하는 것 또한 좋은 방법
* 쉬운 테스트, 예외적인 테스트
* 완급 조절